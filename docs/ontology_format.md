# Ontology Format Specification

This document describes the ontology format generated by PowerBI Ontology Extractor.

## Overview

The ontology format is a structured representation of semantic intelligence extracted from Power BI models. It includes entities, relationships, business rules, and metadata.

## Structure

```json
{
  "name": "OntologyName",
  "version": "1.0.0",
  "source": "Power BI: dashboard.pbix",
  "entities": [...],
  "relationships": [...],
  "business_rules": [...],
  "metadata": {...}
}
```

## Entities

An entity represents a business concept (typically a Power BI table).

### Entity Structure

```json
{
  "name": "Shipment",
  "description": "Shipment entity with tracking",
  "entity_type": "standard",
  "properties": [
    {
      "name": "ShipmentID",
      "data_type": "String",
      "required": true,
      "unique": true,
      "description": "Primary key",
      "constraints": []
    },
    {
      "name": "Temperature",
      "data_type": "Decimal",
      "required": false,
      "unique": false,
      "description": "Temperature reading",
      "constraints": [
        {
          "type": "range",
          "value": {"min": -20, "max": 40},
          "message": "Temperature must be between -20 and 40"
        }
      ]
    }
  ],
  "source_table": "Shipment"
}
```

### Entity Types

- **standard**: Regular entity
- **dimension**: Dimension table (small, many relationships)
- **fact**: Fact table (large, has measures)
- **date**: Date/calendar table
- **bridge**: Bridge table (many-to-many relationships)

### Property Data Types

- `String`: Text data
- `Integer`: Whole numbers
- `Decimal`: Decimal numbers
- `Date`: Date/time values
- `Boolean`: True/false values

### Constraints

Constraints define validation rules for properties:

#### Range Constraint
```json
{
  "type": "range",
  "value": {"min": 0, "max": 100},
  "message": "Value must be between 0 and 100"
}
```

#### Enum Constraint
```json
{
  "type": "enum",
  "value": ["Active", "Inactive", "Pending"],
  "message": "Status must be one of: Active, Inactive, Pending"
}
```

#### Regex Constraint
```json
{
  "type": "regex",
  "value": "^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$",
  "message": "Invalid email format"
}
```

#### Reference Constraint
```json
{
  "type": "reference",
  "value": "Customer.CustomerID",
  "message": "Must reference existing Customer"
}
```

## Relationships

Relationships define how entities are connected.

### Relationship Structure

```json
{
  "from_entity": "Shipment",
  "from_property": "CustomerID",
  "to_entity": "Customer",
  "to_property": "CustomerID",
  "relationship_type": "belongs_to",
  "cardinality": "many-to-one",
  "description": "Shipment belongs to Customer"
}
```

### Relationship Types

- **has**: Entity has related entities (one-to-many)
- **belongs_to**: Entity belongs to another (many-to-one)
- **related_to**: General relationship
- **contained_in**: Containment relationship

### Cardinality

- **one-to-one**: Each entity relates to exactly one other
- **one-to-many**: One entity relates to many others
- **many-to-one**: Many entities relate to one
- **many-to-many**: Many-to-many relationship

## Business Rules

Business rules are extracted from DAX measures and represent business logic.

### Business Rule Structure

```json
{
  "name": "HighRiskShipmentDetection",
  "entity": "Shipment",
  "condition": "Temperature > 25 OR Vibration > 5",
  "action": "classify_as_high_risk",
  "classification": "HighRisk",
  "description": "Detect high-risk shipments",
  "priority": 1,
  "source_measure": "High Risk Shipments"
}
```

### Rule Components

- **name**: Unique identifier for the rule
- **entity**: Entity this rule applies to
- **condition**: Logical condition (e.g., "RiskScore > 80")
- **action**: Action to take when condition is met
- **classification**: Classification value (e.g., "HighRisk")
- **priority**: Rule priority (higher = more important)
- **source_measure**: Original DAX measure name

### Rule Types

Rules can be:
- **Classification**: Classify entities based on conditions
- **Validation**: Validate data against rules
- **Calculation**: Compute derived values
- **Alert**: Trigger alerts when conditions are met

## Metadata

Metadata provides context about the ontology.

```json
{
  "metadata": {
    "generation_date": "2025-01-31T10:00:00Z",
    "source_model": "Supply_Chain_Operations",
    "extraction_tool": "powerbi-ontology-extractor",
    "tool_version": "0.1.0"
  }
}
```

## Complete Example

```json
{
  "name": "SupplyChain_Ontology",
  "version": "1.0.0",
  "source": "Power BI: Supply_Chain_Operations.pbix",
  "entities": [
    {
      "name": "Shipment",
      "description": "Shipment with tracking",
      "properties": [
        {
          "name": "ShipmentID",
          "data_type": "String",
          "required": true,
          "unique": true
        },
        {
          "name": "Temperature",
          "data_type": "Decimal",
          "constraints": [
            {
              "type": "range",
              "value": {"min": -20, "max": 40}
            }
          ]
        }
      ]
    }
  ],
  "relationships": [
    {
      "from_entity": "Shipment",
      "to_entity": "Customer",
      "relationship_type": "belongs_to",
      "cardinality": "many-to-one"
    }
  ],
  "business_rules": [
    {
      "name": "HighRiskDetection",
      "entity": "Shipment",
      "condition": "Temperature > 25",
      "action": "classify_as_high_risk",
      "classification": "HighRisk"
    }
  ],
  "metadata": {
    "generation_date": "2025-01-31T10:00:00Z"
  }
}
```

## Versioning

Ontologies are versioned using Semantic Versioning:
- **MAJOR**: Breaking changes to structure
- **MINOR**: New features, backwards compatible
- **PATCH**: Bug fixes, backwards compatible

## Validation

Ontologies can be validated against this schema. Use the JSON Schema exporter to generate validation schemas.

## Export Formats

The same ontology can be exported to:
- **Fabric IQ**: Microsoft Fabric format
- **OntoGuard**: Validation firewall format
- **JSON Schema**: Standard validation format
- **OWL/RDF**: Semantic web format

See [Export Modules](../api_reference.md#export-modules) for details.

## Best Practices

1. **Naming**: Use clear, descriptive names
2. **Documentation**: Include descriptions for all entities and properties
3. **Constraints**: Add validation constraints where appropriate
4. **Relationships**: Define all important relationships
5. **Business Rules**: Extract all business logic from DAX
6. **Versioning**: Increment version when making changes
7. **Metadata**: Include generation metadata

## Migration

When updating ontologies:

1. **Version bump**: Update version number
2. **Backward compatibility**: Maintain compatibility when possible
3. **Migration guide**: Document breaking changes
4. **Deprecation**: Mark deprecated features before removal

---

For API usage, see [API Reference](api_reference.md).
